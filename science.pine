// @version=4
study("science #1", shorttitle='"science #1"')

res = input(title="Timeframe", type=input.resolution, defval="")

HTFo = timeframe.period == '1'   ?   '3'     : 
  timeframe.period == '3'   ?   '5'    : 
  timeframe.period == '5'   ?   '15'    : 
  timeframe.period == '15'  ?   '60'    : 
  timeframe.period == '30'  ?   '120'   : 
  timeframe.period == '45'  ?   '60'   : 
  timeframe.period == '60'  ?   '120'   : 
  timeframe.period == '120' ?   '240'   : 
  timeframe.period == '180' ?   '240'   : 
  timeframe.period == '240' ?   'D'     : 
  timeframe.period == 'D'   ?    'W'    : ""
  
[l, c, h, o, v] = security(syminfo.tickerid, res == "" ? HTFo: res, [low, close, high, open, volume])
[ll, cc, hh, oo, vv] = security(syminfo.tickerid, timeframe.period, [low, close, high, open, volume])
f_LazyLine(_data, _length) =>
    w1 = 0, w2 = 0, w3 = 0
    L1 = 0.0, L2 = 0.0, L3 = 0.0
    w = _length / 3 //divide period lengths by 3. "the number that shall not be counted"
    
    if _length > 2 
        w2 := round(w) // make a integer square
        w1 := round((_length-w2)/2) // cut it in half
        w3 := int((_length-w2)/2) // make it an integer square
        
        L1 := wma(_data, w1) // average in steps of perfect squares 
        L2 := wma(L1, w2) // fold a second time
        L3 := wma(L2, w3) // fold squares a third time - this makes a line that "fits"
    else
        L3 := _data
    L3
    
//stoch
stochf(cloz, hi, lo) => 
	speriodK = input(14, title="%K Length", minval=1)
	ssmoothK = input(1, title="%K Smoothing", minval=1)
	speriodD = input(3, title="%D Smoothing", minval=1)
	kk = sma(stoch(cloz, hi, lo, speriodK), ssmoothK)
	dd = sma(kk, speriodD)
	[kk, dd]
[kk, dd] = stochf(cc, hh, ll)

//kdj
kdj() =>
    length = input(9, title="period")
    signal = input(3, title="signal")
    hi = highest(h, length)
    lo = lowest(l , length)
    k = 100*((c-lo)/(hi-lo))
    pK = ema(k, signal)
    pD = ema(pK, signal)
    pJ = 3*pK-2*pD
    kshift = 90
    [pK,pD, pJ, kshift]

//RSI

m_rsi(len) => 
    src = input(close, "Source", type = input.source)
    up = rma(max(change(src), 0), len)
    down = rma(-min(change(src), 0), len)
    rsi = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))
    rsi

// Calculate RSI
rsi1 = m_rsi(7)
rsi2 = m_rsi(13)
rsi3 = m_rsi(23)
rsicross = rsi1 > rsi2 and rsi2 > rsi3
// Calculate RSI
rsi = rsi(close, 7)
rsi_color = rsi > 75 ? color.red : rsi < 27 ? rsicross? color.yellow : color.green : color.white
 
// volume
norm(data) =>
    a = (data-sma(data, 3))
    b = stdev(data,3)
    ema(a/b, 12)

lb_vol(vol,cloz) =>
    slow = input(12, "Short period")
    fast = input(26, "Long period")
    signal = input(9, "Smoothing period")
    maFast = ema( vol * cloz, fast ) / ema( vol, fast ) 
    maSlow = ema( vol * cloz, slow ) / ema( vol, slow )
    d = maSlow - maFast 
    maSignal = ema( d, signal ) 
    dm=d-maSignal
    d_color=d>=0? (d>d[1]?color.green:color.orange) : (d<d[1]?color.red:color.orange)
    [d, dm, d_color]
 
//moef 

moef (data) =>
	src = norm(data)*1.1
	src1 = nz(src[1], src)
	src2 = nz(src[2], src1)
	src3 = nz(src[3], src2)

	moef = src
	moef := 0.13785 * (2 * src - src1) +
	         0.0007 * (2 * src1 - src2) +
	         0.13785 * (2 * src2 - src3) +
	         1.2103 * nz(moef[1], moef) -
	         0.4867 * nz(moef[2], moef)
	moef
	moefColor = #6d1e7f
	[moef, moefColor]
 
// homodyne 

// --- Start the Homodyne Discriminator Caculations
//
// Mutable Variables (non-series)
HomodyneDiscriminator(data) =>
    C1     = 0.0962
    C2     = 0.5769
    Df     = 0.5

    //
    float Period = na
    C3      = (nz(Period[1])*0.075+0.54)
    smooth    = ((data*8.0) + (data[1]*6.0) + (data[2]*4.0) + (data[3]))/10.0
    dDeTrend  = (smooth*C1 + nz(smooth[2])*C2 - nz(smooth[4])*C2 - nz(smooth[6])*C1)*C3

    // Compute InPhase and Quadrature components
    Q1      = (dDeTrend*C1 + nz(dDeTrend[2])*C2 - nz(dDeTrend[4])*C2 - nz(dDeTrend[6])*C1)*C3
    I1      = nz(dDeTrend[3])

    // Advance Phase of I1 and Q1 by 90 degrees
    jI      = (I1*C1 + nz(I1[2])*C2 - nz(I1[4])*C2 - nz(I1[6])*C1)*C3
    jQ      = (Q1*C1 + nz(Q1[2])*C2 - nz(Q1[4])*C2 - nz(Q1[6])*C1)*C3

    // Phaser addition for 3 bar averaging
    I2_  = I1 - jQ
    Q2_  = Q1 + jI
    // Smooth i and q components before applying discriminator
    I2 = 0.0
    I2  := 0.2*I2_ + 0.8*nz(I2[1])
    Q2 = 0.0
    Q2  := 0.2*Q2_ + 0.8*nz(Q2[1])

    // Extract Homodyne Discriminator
    Re_ = I2*nz(I2[1]) + Q2*nz(Q2[1])
    Im_ = I2*nz(Q2[1]) - Q2*nz(I2[1])
    Re = 0.0
    Re  := 0.2*Re_ + 0.8*nz(Re[1])
    Im = 0.0
    Im  := 0.2*Im_ + 0.8*nz(Im[1]) 

    dp_ = iff(Re!=0 and Im!=0 , 6.28318/atan(Im/Re) , 0)
    II  = nz(Period[1])
    dp  = max(max(min(min(dp_,1.5*II),50),0.6667*II),6)
    Period := dp*0.2 + nz(Period[1])*0.8
    SmoothPeriod = 0.0
    SmoothPeriod := 0.33*Period + nz(SmoothPeriod[1])*0.67
    RVILength = round(SmoothPeriod*Df -1)
    p = 0.0
    p := p + SmoothPeriod[0]
    p := floor(p)
    p := round(p)
    //plot(p)
    //p = integer()
    CO=volume*close-volume*open
    HL=high*volume-low*volume

    value1 = (CO + 2*CO[1] + 2*CO[2] + CO[3])/6
    value2 = (HL + 2*HL[1] + 2*HL[2] + HL[3])/6
    num=0.0
    denom=0.0

    looplength = 100
    for i = 0 to looplength
        if (i >= RVILength)
            break
        num:=num + value1[i]
        denom:=denom + value2[i]

    RVI=denom!=0?num/denom:0
    RVIsig=(RVI+ 2*RVI[1] + 2*RVI[2] + RVI[3])/6
    RVIhist = (RVI - RVIsig) * 2
    RVIhist_color = RVIhist > 0 ? (RVIhist > RVIhist[1] ? color.lime : color.green) : (RVIhist < RVIhist[1] ? #EF3232 : color.red )

    [RVI, RVIsig, RVIhist, RVIhist_color]

//calculate values
[RVI, RVIsig, RVIhist, RVIhist_color] = HomodyneDiscriminator(close)
[d, dm, d_color] = lb_vol(vv,cc)
[cd, cdm, cd_color] = lb_vol(volume,close)
[theMoef, moefColor] = moef(cd)
[pK, pD, pJ, kshift] = kdj()

// Plotting
band0 = hline(0, "Center", color=color.new(color.gray, 50), linestyle=hline.style_dashed)
band1 = hline(100, "rsi", color=color.new(color.gray, 50), linestyle=hline.style_dashed) // rsi
band2 = hline(-100, "kdj", color=color.new(color.gray, 50), linestyle=hline.style_dashed) // kdj
band3 = hline(-200, "homodyne", color=color.new(color.gray, 50), linestyle=hline.style_dashed) // homdyne
//band4 = hline(-300, "stoch", color=color.new(color.gray, 50), linestyle=hline.style_dashed) // stoch

//RSI
plot(rsi, color= rsi_color, transp=0, linewidth=2, style=plot.style_circles, title="RSI")
//KDJ
pJColor = if (change(pJ) > 0)
    color.green
else 
    color.fuchsia

plot(avg(pK, pD)/1.5-kshift, color=color.orange, transp=0, linewidth=1, title="KD")
plot(pJ/1.5-kshift, color=pJColor, transp=0, linewidth=1, title="J")
//stoch
plot(kk-200, title="%K", color=#2962FF)
plot(dd-200, title="%D", color=#FF6D00)
//lazybear vol + exponential filter
//plot(norm(d)*40-160, color = d_color)
//plot((theMoef)*40-160, title="MOEF", linewidth=1, color=color.fuchsia, transp=0)
//homodyne trendline
//plot(RVIhist*50, color=RVIhist_color, title="Hist", style=plot.style_columns, transp=0)
//fill(band2, band3, color =   change(pJ) > 0? color.green :color.red, transp= 70)
fill(band1, band3, color=color.rgb(126, 87, 194, 90), title="Background")